---
title: My Document
output: html_document
# params:
#   year: 2018
---

```{r}

library(jsonlite)
# library(WGCNA)
library(yaml)
library(ggplot2)
# library(ggThemeAssist)
library(dplyr)
library(data.table)
#library(tidyverse)
# library(biomaRt)
library(RColorBrewer)
library(gridExtra)
# library(ComplexHeatmap)
# library(slingshot)
# library(ggpubr)
# library(monocle3)
# library(mixOmics)
#library(EnhancedHeatmap)
# library(fgsea)
# library(dynamicTreeCut)
# library(flashClust)
library(igraph)
library(pheatmap)

```

# Immune Cell Datamining

The pipeline does the bulk of the pre-processing on its own.

```{r}

timestamp <- format(Sys.time(), "%Y-%m-%d %H:%M:%S")

CONFIG <- list(
  # [File Path Locations]
  "srcDir" = "./src",
  "resultsDir" = "./results",
  
  "dataHomeLocal" = "/media/michael/Nguyen-Lab/sequencing-data",
  "dataHomeRemote" = "../sequencing-data",
  
  "defaultExclude" = c("meta", "Raw_FASTQ"),
  
  # [Analysis Metrics]
  "minFeatRNA" = 200,
  "mtExprLimit" = 20,        # The highest % of MT gene reads allowed
  "numPCs" = 30,             # Amount of principal components to generate
  "clusterResolution" = 1
)

source(file.path(CONFIG$srcDir, "util.R"))
.init_env(remote=FALSE)
```

## Preprocessing

------------------------------------------------------------------------

### Metadata Wrangling

```{r "Adding New Metadata"}

samples_sle$condition <- NA

# Classify condition using identifier substring (i.e. `_SLE_` or `_HD_`)
names <- unique(samples_sle$orig.ident)

disease <- grep("SLE", names, value = TRUE)
samples_sle$condition[samples_sle$orig.ident %in% disease] <- "SLE"


healthy <- grep("HD", names, value = TRUE)
samples_sle$condition[samples_sle$orig.ident %in% healthy] <- "Healthy"


# samples$condition <- ifelse(samples$sample %in% c("30_HUMAN_GVHD_A6_G1", "31_HUMAN_GVHD_A7_G1", "32_HUMAN_GVHD_A8_G1"), "healthy", "disease")
```

```{r "Adjusting Metadata"}

# Duplicate Metadata Column
samples@meta.data$cell_type <- samples@meta.data$seurat_clusters

# Delete Metadata Column
samples@meta.data$orig.ident <- NULL
```

```{r "Remove trailing numbers from barcodes"}

new_metadata$barcodes <- gsub('.{2}$', '', rownames(new_metadata))

new_metadata <- new_metadata[!duplicated(new_metadata$barcodes), ]

samples@meta.data$orig.barcodes <- rownames(samples@meta.data)

```

```{r "Increase/decrease barcode numbering"}

increase_final_digit <- function(x) {
  hyphen_pos <- regexpr("-[^-]*$", x)
  prefix <- substr(x, 1, hyphen_pos)
  digit <- as.numeric(substring(x, hyphen_pos + 1)) + 1 # <-
  
  new_string <- paste0(prefix, digit)
  
  return(new_string)
}

split_gvhdmeta <- split(gvhdmeta, gvhdmeta$experiment)

new_rownames <- sapply(rownames(split_gvhdmeta[[3]]), increase_final_digit)

rownames(split_gvhdmeta[[3]]) <- new_rownames

merged_gvhdmeta <- do.call(rbind, split_gvhdmeta)

```

```{r "Integrating Existing Metadata"}
# Split & remerge metadata tables
split_gvhdmeta <- split(gvhdmeta, gvhdmeta$experiment)

merged_metadata <- merge(samples@meta.data, gvhdmeta, by.x="barcodes", by.y= "barcode", all.x=TRUE)

rownames(merged_metadata) <- merged_metadata$orig.barcode
samples@meta.data <- merged_metadata

# TODO: try using 'rbind' function
samples <- AddMetaData(samples, gvhdmeta_correct)
samples <- subset(samples, subset = experiment != 'NA')

# Notes about merging metadata (because the docs suck):
# - Function will automatically fill
#   NA values for unmatched cells
# - can't have a column named "barcode"?

# Remove entries with NA values

clean_names <- rownames(samples@meta.data %>% filter(!is.na(experiment)))
```

```{r}

# Double check duplicate barcodes
View(samples@meta.data)

length(merged_metadata$barcode)
length(unique(merged_metadata$barcode))

unique_barcodes_list <- unique(merged_metadata$barcode)

# Manually Update Sample Condition Names
print(unique(samples@meta.data$orig.sample))

samples@meta.data$orig.sample[samples@meta.data$orig.sample == "GSM6008408_PREP0128_ESint12162A_G9v1_SCb_BWH4_48h"] <- "48h"

```

## Dimension Reduction Analysis

------------------------------------------------------------------------

Calculate the subset of features that exhibit high cell-to-cell variation in the dataset (i.e. they are highly expressed in some cells and lowly expressed in others).

It is used by the `RunPCA()` function rather than all of the genes to avoid redundant comparisons (such as expression of fundamental cell cycle genes?)

Tweaking which PCs (`dims` parameter) are being used is a crucial step in filtering out irrelevant variances (Ex: Cell cycle genes).

Generally, the first few principal components generated (which are the "most notable variances"), are often associated with the cell cycle (assuming asynchronous growth/division)

```{r}

names(samples@reductions)

print(samples[["pca"]], dims = 1:2, nfeatures = 30)

# Determine "dimensionality" by visualizing amount of change 
ElbowPlot(samples, reduction = "pca")

VizDimLoadings(samples, dims=1:2, reduction="orig.pca")

DimPlot(Epi_samples, reduction="orig.pca", label = TRUE, pt.size = 0.5)

DimHeatmap(samples, reduction="orig.pca", dims = c(8, 10))
```

### Regressing Out Unwanted Variation

(i.e. cell cycle, HLA, or mitochondrial genes)

```{r}
# Regressing Out Unwanted Variation
samples <- regress_cell_cycle(samples)

```

### Batch Effect Analysis

-   orig.pca

```{r}

# Check For Batch Effect
fig <- DimPlot(samples, reduction="integrated.cca", group.by="orig.sample")

# Generate Batch Effect Comparison Plot
visualize_batch_effect(Epi_samples)

```

## Marker Identification

------------------------------------------------------------------------

```{r "Identify Cluster Markers"}

find_gene(Epi_samples, "FX")

# Identify Cluster Markers
de_markers_human <- FindAllMarkers(samples_human, only.pos=TRUE, min.pct=0.10,
                             logfc.threshold=0.25, group.by="integrated.cca.clusters")


de_markers <- FindMarkers(samples, only.pos = TRUE,
                          min.pct=0.01, logfc.threshold = 0.25, 
                          group.by="integrated.cca.clusters", ident.1=15)


# Print top n markers for each cluster
top_markers <- print_top_markers(de_markers_dermis, n=20)

topMarkers <- de_markers_epi %>% group_by(cluster) %>% top_n(n=20, wt=avg_log2FC)
View(topMarkers)


# View all identified markers matching a list of genes
potential_clusters <- subset(all_markers_sle, gene %in% MARKERS$Treg)
table(potential_clusters$cluster)


```

```{r}
nk.markers <- FindConservedMarkers(ifnb, ident.1 = "NK", grouping.var = "stim", verbose = FALSE)

write.csv(topMarkers, "results/topMarkers.csv", row.names = FALSE)

# Remember that clusters /= PCs
# Markers are identified PER CLUSTER (or other specified grouping)

Idents(samples)

de_genes <- rownames(de_markers)
de_expr <- GetAssayData(samples1a, slot = "data")[de_genes, ]
```

## Cell Type Annotation

```{r "Annotate Cell Types (Using Clusters)"}

# Cell Type
samples_sle$cell_type <- samples_sle@active.ident

samples_sle$cell_type[samples_sle@active.ident %in% c(7, 10, 18, 23)] <- "Treg"

treg_cluster <- subset(samples_mouse, subset = SingleR_main == "T cells")

```

```{r "Annotate Cell Types (Using N-Expression)"}

expr_mat <- GetAssayData(Dermis_samples, slot = "data")

common_genes <- intersect(rownames(expr_mat), MARKERS$`T reg`)
expr_sub <- expr_mat[common_genes, , drop = FALSE]

marker_counts <- colSums(expr_sub > 0)

cells_to_keep <- names(marker_counts[marker_counts >= 5])
treg_subset <- subset(Dermis_samples, cells = cells_to_keep)

rm(expr_mat, common_genes, expr_sub, marker_counts, cells_to_keep)

```

```{r "Annotate Cell Types (Using SingleR)"}

library(SingleR)
library(celldex)

# ref_human <- celldex::HumanPrimaryCellAtlasData()
# ref_mouse <- celldex::MouseRNAseqData()

sce_sle <- as.SingleCellExperiment(samples_sle)

# Main Cell Type Labeling
singler_results_main <- SingleR(
  test = sce_sle,
  ref = ref_human,
  labels = ref_human$label.main
)

samples_sle$SingleR_main <- singler_results_main$labels

# Fine Cell Type Labeling
singler_results_fine <- SingleR(
  test = sce_sle,
  ref = ref_human,
  labels = ref_human$label.fine
)

samples_sle$SingleR_fine <- singler_results_fine$labels

samples_test <- subset(samples_human, ident=8)

```

## Creating Cell Type Subsets

```{r}
levels(samples)
Idents(samples_cc) <- samples_cc$seurat_clusters

# Subset Cells
samples_tcell <- subset(samples, ident=c("CD4 Treg", "CD4 Th1", "CD4 T cm", "CD8 TRM", "CD4 memory", "CD4 Th17", "CD8 act."))

samples_cd4 <- subset(samples, ident=c("CD4 Treg", "CD4 Th1", "CD4 T cm", "CD4 memory", "CD4 Th17"))

samples_mono <- subset(samples, ident=c("Monocytes", "Macrophages", "DCs"))


# Check sample composition of subset
table(treg_subset$orig.ident)

```

## Analyzing Expression Levels

------------------------------------------------------------------------

```{r}

AverageExpression(samples_sle, features=c("TIGIT", "CD8A", "CD8B", "CD4", "FOXK1", "MTOR", "HIF1A"), group.by=c("condition", "cell_type"))

```

```{r "Miscellaneous Figures"}

counts <- GetAssayData(samples_sle, slot = "counts")

max_counts_per_cell <- apply(counts, 2, max)

min_read <- min(max_counts_per_cell)
max_read <- max(max_counts_per_cell)

cat("Minimum of per-cell max counts:", min_read, "\n")
cat("Maximum of per-cell max counts:", max_read, "\n")

# For each cell, which gene has the max count
gene_with_max_per_cell <- apply(counts, 2, function(x) names(which.max(x)))

# Which cell has the absolute highest single-gene count?
cell_with_max <- names(which.max(max_counts_per_cell))
gene_at_max <- gene_with_max_per_cell[cell_with_max]

cat("Highest single gene count is", max_read, 
    "in cell", cell_with_max,
    "for gene", gene_at_max, "\n")

target <- "FOXK1"

foxk1_counts <- counts[target, ]

# Highest observed count
max_count <- max(foxk1_counts)
min_count <- min(foxk1_counts)   # optional, for completeness

cat(target, "max count:", max_count, "\n")
cat(target, "min count:", min_count, "\n")
```

```{r "Primary Heatmap"}

find_gene(samples, "CXCR3")

cell_list <- c("CD4 Treg", "CD8 act.", "CD8 TRM", "CD4 Th17")
samples_subset <- subset(treg_subset, idents=cell_list)



gene_list <- c("FOXK1", "HIF1A", "CDK5RAP1", MARKERS$`Foxk1 Targets`)

sparse_mat <- AverageExpression(pb_samples_cca,
                                assay="RNA",
                                layer = "scale.data",
                                features = gene_list,
                                group.by = c("condition"))

mat <- as.matrix(sparse_mat$RNA)

mat[is.na(mat)] <- 0 # Below average doesn't mean 0 expression 

```

```{r "Investigating Exhausted Tc Populations"}

# --== Subset By Cluster ==--
tSubset <- subset(samples, idents = c("T Cells", "CD4 T Cells", "CD8 T Cells"))

length(Cells(tSubset))


# --== Subset By Genes ==--
length(WhichCells(tSubset, expression = TIGIT > 1))

exhaustSubset <- subset(tSubset, cells = WhichCells(tSubset, expression = TIGIT > 1))
healthySubset <- subset(tSubset, cells = WhichCells(tSubset, expression = TIGIT < 1))

#validate
length(Cells(healthySubset))
length(WhichCells(healthySubset, expression = TIGIT > 1))

# violin plot of expression
tSubsetMerge <- merge(exhaustSubset, healthySubset)

tSubsetMerge$dataset <- c(
  rep("Exhausted", ncol(seurat_obj1@assays$RNA)), 
  rep("Healthy", ncol(seurat_obj2@assays$RNA)))


VlnPlot(exhaustSubset, features = genesOfInterest, log = TRUE, 
        pt.size = 0.1)
VlnPlot(healthySubset, features = genesOfInterest, log = TRUE, 
        pt.size = 0.1)


# Check subset size
print(nrow(cells_with_gene_expression))

exhaustSubset <- subset(seurat_obj, subset = RNA, gene_symbol = gene_of_interest)

```

## Pseudobulking Analysis

```{r}

counts <- GetAssayData(samples_sle, slot = "counts")  # raw counts
meta   <- samples_sle@meta.data

# Define grouping
meta$group <- paste(meta$orig.ident, meta$cell_type, sep = "_")

# Collapse counts into pseudobulk matrix
pseudobulk_counts <- do.call(cbind, lapply(unique(meta$group), function(g) {
  cells <- rownames(meta[meta$group == g, ])
  if (length(cells) == 1) {
    as.numeric(counts[, cells, drop = FALSE])  # force numeric
  } else {
    rowSums(counts[, cells, drop = FALSE])
  }
}))

# Assign proper dimnames
rownames(pseudobulk_counts) <- rownames(counts)
colnames(pseudobulk_counts) <- unique(meta$group)

# Make sure it's integer, as DESeq2 requires
storage.mode(pseudobulk_counts) <- "integer"

pb_meta <- data.frame(
  sample    = sub("_(.*)$", "", colnames(pseudobulk_counts)),
  cell_type = sub(".*_", "", colnames(pseudobulk_counts))
)

# Add condition from Seurat metadata
# Make sure sample IDs are consistent
pb_meta$sample <- sub("_(.*)$", "", colnames(pseudobulk_counts))

# Build sample-to-condition lookup
sample_conditions <- meta[!duplicated(meta$orig.ident), c("orig.ident", "condition")]
rownames(sample_conditions) <- sample_conditions$orig.ident

# Map condition for each pseudobulk column
pb_meta$condition <- sample_conditions[as.character(pb_meta$sample), "condition"]

# Restore rownames as pseudobulk column names
rownames(pb_meta) <- colnames(pseudobulk_counts)


```

```{r}

dds <- DESeqDataSetFromMatrix(
  countData = pseudobulk_counts,
  colData   = pb_meta,
  design    = ~ cell_type + condition
)

dds <- DESeq(dds)

res <- results(dds, contrast = c("condition", "SLE", "Healthy"))
```

```{r}

# Suppose you have a vector of target genes
targets <- MARKERS$Interest

df <- as.data.frame(res)
df$gene <- rownames(df)
df <- df %>% filter(gene %in% targets)

df$negLog10Padj <- -log10(df$padj)

ggplot(df, aes(x = gene, y = log2FoldChange)) +
  geom_point(aes(size = negLog10Padj, color = log2FoldChange)) +
  scale_color_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
  scale_size_continuous(name = "-log10 padj") +
  theme_minimal() +
  coord_flip() +
  labs(x = "Gene", y = "log2 Fold Change", color = "log2FC")

```

```{r}
vsd <- vst(dds)  # variance stabilizing transformation
mat <- assay(vsd)[targets, ]  # subset to target genes


pheatmap(mat, scale = "row", cluster_cols = TRUE, cluster_rows = TRUE,
         main = "Expression of target genes")

annotation_col <- as.data.frame(colData(vsd)[, c("condition","cell_type")])
pheatmap(mat, scale="row", cluster_cols=FALSE, cluster_rows=FALSE,
         annotation_col=annotation_col)

```

```{r}

library(EnhancedVolcano)
EnhancedVolcano(df,
                lab = df$gene,
                x = 'log2FoldChange',
                y = 'padj',
                pCutoff = 0.05,
                FCcutoff = 1)


```

## Gene Network Analysis

------------------------------------------------------------------------

### Gene Module Scoring

|          **Pathway**          | **Gene Ontology ID** |
|:-----------------------------:|:--------------------:|
|   Oxidative Phosphorylation   |     `GO:0006119`     |
|           Mitophagy           |     `GO:0000422`     |
|           Autophagy           |     `GO:0006914`     |
|     Fatty Acid Oxidation      |     `GO:0019395`     |
| Cholesterol Metabolic Process |     `GO:0008203`     |
|           TCA Cycle           |     `GO:0006099`     |
|            Hypoxia            |                      |
|          Senescence           |                      |
|      Gloycolytic Process      |     `GO:0006096`     |

```{r}

# library(org.Hs.eg.db)
# library(org.Mm.eg.db)

glycolysis_genes <- AnnotationDbi::select(org.Hs.eg.db, 
                                          keys = "GO:0006096", 
                                          columns = c("SYMBOL"), 
                                          keytype = "GOALL")

glycolysis_genes <- unique(glycolysis_genes$SYMBOL)

# Gluconeogenesis (GO:0006094)
gluconeogenesis_genes <- AnnotationDbi::select(org.Hs.eg.db, 
                                               keys = "GO:0006094", 
                                               columns = c("SYMBOL"), 
                                               keytype = "GOALL")

gluconeogenesis_genes <- unique(gluconeogenesis_genes$SYMBOL)
```

### Pearson Correlation Analysis

```{r}

Features(samples)[Features(samples) %like% "HIF"]

samples@meta.data$Gluconeogenesis1 <- NULL
Features(samples)

module1 <- 'Exhaustion'
module2 <- 'Senescence'

# Add Gene Module Scores (For all marker groups)
module_list <- names(MARKERS[8:17])
for (mod in module_list) {
  samples <- AddModuleScore(samples, MARKERS[mod], name=mod)
}

# (Manually)
samples <- AddModuleScore(samples, gene_list, name= 'Foxk1Module')

# Find Average Expression For Specific Gene
avg_expr <- AverageExpression(samples, group.by="samplename", features="GPR84")

# Split and find average per biopsy
metadata_split <- split(samples@meta.data, samples$samplename)

corr_table <- data.frame(matrix(ncol=2,nrow=0))
for (i in 1:length(names(metadata_split))) {
  name1 <- paste(module1,"1",sep="")
  mean1 <- as.numeric(mean(metadata_split[[i]][[name1]]))
  name2 <- paste(module2,"1",sep="")
  #mean2 <- as.numeric()
  mean2 <- as.numeric(mean(metadata_split[[i]][[name2]]))
  
  corr_table <- rbind(corr_table, c(mean1, mean2))
  rm(mean1, name1, mean2, name2)
}

colnames(corr_table) <- c(module1, module2)

correlation <- cor(as.numeric(corr_table[[module1]]), as.numeric(corr_table[[module2]]), method='pearson')

fig3 <- ggscatter(corr_table, x = module1, y = module2, 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson",
          xlab = module1, ylab = module2)


rm(metadata_split, corr_table)
 
```

### Weighted Gene Co-Expression Network Analysis (WGCNA)

```{r}



samples <- NormalizeData(samples)

samples <- FindVariableFeatures(samples_cd4, selection.method = "vst", nfeatures = 1000)



# Extract expression matrix for highly variable genes
data <- GetAssayData(samples, assay = "RNA", slot = "data")


# Convert data to numeric matrix
data <- t(as.matrix(data))

# Choose soft thresholding power
softPower <- 24

# Perform WGCNA analysis
network <- blockwiseModules(data, power = softPower, TOMType = "unsigned", minModuleSize = 30, reassignThreshold = 0, mergeCutHeight = 0.25, numericLabels = TRUE, pamRespectsDendro = FALSE,saveTOMs = TRUE, verbose = 3)

# Module colors (labels)
module_colors <- network$colors

# Module eigengenes (MEs)
module_eigengenes <- network$MEs

# Print out the module colors and eigengenes
print(module_colors)
print(module_eigengenes)


# Convert module colors to a vector
module_colors <- labels2colors(network$colors)

# Plot the dendrogram and module colors
plotDendroAndColors(network$dendrograms[[1]], colors=module_colors, "Module colors", dendroLabels = FALSE, hang = 0.03)

g <- graph(n = length(network), edges = length(network$colors), directed = FALSE)

# Set node attributes
V(g)$name <- paste("Module", 1:length(network$colors))
V(g)$color <- network$colors

plot(g)

graph_network <- graph_from_adjacency_matrix(network)

nodes <- data.frame(
  Gene = colnames(data),
  Module = module_colors
)

# Save to CSV
write.csv(nodes, file = "nodes.csv", row.names = FALSE)

# Calculate TOM matrix
TOM <- TOMsimilarityFromExpr(data, power = 6)

# Get gene names
gene_names <- rownames(data)

# Create a list of edges above a threshold
threshold <- 0.1
edges <- which(TOM > threshold, arr.ind = TRUE)

# Create a data frame for edges
edges_df <- data.frame(
  Source = gene_names[edges[, 1]],
  Target = gene_names[edges[, 2]],
  Weight = TOM[edges]
)

# Remove self-loops
edges_df <- edges_df[edges_df$Source != edges_df$Target, ]

# Save to CSV
write.csv(edges_df, file = "edges.csv", row.names = FALSE)

```

### Network Visualization

```{r}
library('igraph')
# library('network')
# library('networkD3')
# library('intergraph')
m<-adjacency

source=c()
target=c()
corr<-c()
g1<-rownames(data_subset)[1:dim(m)[1]]
g2<-g1

for(gene in g1){
  for(gen in g2){
    if(m[gene,gen]<0.9999 & m[gene,gen]>0.3){
      source<-c(source,gene)
      target<-c(target,gen)
      corr<-c(corr,m[gene,gen])
    }
  }
}
NetworkData <- data.frame(source, target)

simpleNetwork(NetworkData,zoom = T)
```

### Gene Set Enrichment Analysis (GSEA)

```{r}

# TODO




```

## Pseudotime Analysis

------------------------------------------------------------------------

```{r}

library(monocle)
library(SingleCellExperiment)

tol_high_contrast_palette <- c("#DDAA33", "#BB5566", "#004488")
tol_vibrant_palette <- c("#0077BB", "#33BBEE", "#009988",
                         "#EE7733", "#CC3311", "#EE3377",
                         "#BBBBBB")
tol_muted_palette <- c("#332288", "#88CCEE", "#44AA99",
                       "#117733", "#999933", "#DDCC77",
                       "#CC6677", "#882255", "#AA4499")




cds <- as.CellDataSet(pb_samples_cca, reduction = 'regressed.umap')

cds <- clusterCells(cds, resolution=0.0009)

plot_cells(cds, color_cells_by = "cluster", show_trajectory_graph = FALSE)

# Draw Trajectories
cds <- learn_graph(cds, use_partition=TRUE, close_loop=FALSE)

plot_cells(cds, color_cells_by = "cluster", label_groups_by_cluster=FALSE, label_leaves=FALSE, label_branch_points=FALSE)

# Order Cells in Pseudotime
cds <- order_cells(cds, root_cells = colnames(cds[,clusters(cds) == 6]))

plot_cells(cds,
           color_cells_by = "pseudotime",
           group_cells_by = "cluster",
           label_cell_groups = FALSE,
           label_groups_by_cluster=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE,
           label_roots = FALSE,
           trajectory_graph_color = "grey60")
```